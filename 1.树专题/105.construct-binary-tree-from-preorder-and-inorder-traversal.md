## Problem

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

++

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

------

### Note

- 方法1（不推荐），直接递归。【注意】时间O:n^2  （由于每个节点都需要在inorder中寻找到所在位置）    空间O:最坏为n^2 （在递归时，传入的是list，而不是索引）
- **方法2**:
  - 由于需要在中序遍历中寻找root，导致时间复杂度过高，则以空间换时间，构建哈希映射，直接将元素的位置存储下来,时间复杂度降为：n。
  - 空间复杂度为n。 传入函数的不是list而是索引
- 方法3：迭代法，用stack模仿递归。参考：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/
- 其他中序+后序，前序+后序（此时还原的树不唯一）都是类似的。

------

### Complexity

- 时间O：-
- 空间O：-

------

### Python

```python
方法2（推荐使用）:

class Solution:

    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        
        def mybuildTree(preorder_l, preorder_r, inorder_l, inorder_r):
            if preorder_l > preorder_r:
                return None
            root = TreeNode(preorder[preorder_l]) 
            i = index[root.val] # 在inorder中，left长度为i-inorder_l; right长度为inorder_r - i
            len_l = i - inorder_l
            root.left = mybuildTree(preorder_l + 1, preorder_l + 1 + len_l - 1, inorder_l, i - 1)
            root.right = mybuildTree(preorder_l + 1 + len_l - 1 + 1, preorder_r, i + 1, inorder_r)
            return root

        index = {num: i for i, num in enumerate(inorder)}    
        root = mybuildTree(0, len(preorder) - 1, 0, len(inorder) - 1)
        return root

递归(不含额外的映射)不推荐:
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        root = TreeNode(preorder[0])
        i = inorder.index(root.val)  # 获取在中序遍历的索引，左子树为[:i], 个数为i，right subtree 是[i+1:]
        root.left = self.buildTree(preorder[1:i+1], inorder[:i])
        root.right = self.buildTree(preorder[i+1:], inorder[i+1:])
        return root
```

### C++

```C++

```



From : https://github.com/dahaiyidi/awsome-leetcode
