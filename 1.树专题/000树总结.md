## Think deeply

主要要一下几种题型

- 二叉树遍历
  - 二叉树的前、中、后序遍历，在 [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) 的题解中有详细的阐述。三种思路：递归、迭代(非统一形式和统一形式)、morris.
  
    - 很多题目可以直接在遍历的基础上修改
    - [814. 二叉树剪枝](https://leetcode-cn.com/problems/binary-tree-pruning/)
  
  ```python
  递归: 
      时间:n
      空间:最坏为n
  class Solution:
      def inorder(self, root):
          if root == None:
              return 
          # 放在这是前序遍历 self.res.append(root.val)
          self.inorder(root.left)
          self.res.append(root.val) # 放在这是中序遍历
          self.inorder(root.right)
          # 放在这是后序遍历  self.res.append(root.val)
  
      def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
          if root == None:
              return []
          self.res = []
          self.inorder(root)
          return self.res
   
  迭代:(模仿递归)
      中序遍历
      时间:n
      空间:最坏为n
  class Solution:
      def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
          if not root:
              return []
          res =  []
          st = []
          while len(st) or root:
              while root:
                  # 一直进入左子树
                  # 放在这是前序遍历 res.append(root.val)
                  st.append(root)
                  root = root.left
                  
              # 如果是后续遍历，则以下三行代码需要重构，具体见迭代（后序遍历）
              root = st.pop() # 子树根节点
              res.append(root.val)  # 放在这是中序遍历，后续遍历正是在中序遍历上修改的
              
              root = root.right # 进入右子树  此处不可以加if(root->right)，无论右子树是否为none,都必须进入右子树。右子树为空，会继续往树根部走。
          return res
      
  迭代（后序遍历，在中序遍历的基础上修改而来）:
  -通过pre，判断右孩子代表的右子树是否已经处理完毕。
  也可以通过，先获取root,right,left, 然后再翻转的方法。
      
  class Solution:
      def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
          st = []
          res = []
          cur = root
          pre = None
          while len(st) != 0 or cur:
              while(cur):
                  st.append(cur)
                  cur = cur.left
                  
              cur = st[-1] ### 与前、中不同的是：后续遍历中，左子树回退到父节点(第一次回退)，不能直接pop父节点，因为需要在进入右子树后，再回退到父节点（(第二次回退)），然后才可以pop
              if not cur.right or pre == cur.right:
                  # 右子树为None,或从右子树回退到该节点，可以res.append了
                  res.append(cur.val)  # 添加节点
                  st.pop()
                  pre = cur
                  cur = None # 下一步需要继续向树根部走
              else:
                  # 说明是第一次回退，则需要先进入右子树
                  cur = cur.right
  
          return res
      
  迭代（前中后统一写法）：
  其实上面的写法具有一定形式的统一性，但是还不具有递归法那样的完美的统一，还有以下解法。
  
  class Solution:
      def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
          if not root:
              return []
  
          res = []
          st = []
          st.append(root)
          while len(st) != 0:
              cur = st.pop()
              if cur:
                  # 非空，用None标记已经访问过中节点，但是还没有添加进入res
  
                  # 放在这是后序遍历st.append(cur)    st.append(None)
  
                  # 对于中序遍历，需要按照right, root, left的顺序压入stack
                  if cur.right: 
                      st.append(cur.right) 
                  
                  # 放在这是中序遍历
                  st.append(cur)
                  st.append(None)
  
                  if cur.left:
                      st.append(cur.left)
  
                  # 放在这是前序遍历st.append(cur)    st.append(None)
                  
              else:
                  # 开始处理中节点
                  cur = st.pop()  # 获取此None标记的中节点
                  res.append(cur.val)
          return res
  
  
  
      
  Morris:
      时间:n
      空间:1
  
  class Solution:
      def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
          if not root:
              return []
          res = []
          while root:
              if root.left:
                  # 左子树存在，找到左子树的最右节点
                  # 如果最右节点pre还没有指向root（第一次找到该点），则pre.right = root,下一循环进入左子树
                  # 如果最右节点pre.right指向root（第二次找到该点），则说明左子树已经遍历完成，断开链接，添加root.val, 进入右子树
                  pre = root.left
                  while pre.right and pre.right != root:
                      pre = pre.right
                  # 此时，pre已经是左子树的最右节点
                  
                  if not pre.right:
                      # 第一次到达该节点，pre.right = root，下一循环继续遍历左子树
                      # 放在这是前序遍历 res.append(root.val) 
                      pre.right = root  
                      root = root.left
  
                  if pre.right == root:
                      # 第二次到达该节点，则说明左子树已经遍历完成，断开链接，添加root.val, 进入右子树
                      pre.right = None
                      res.append(root.val) # 放在这是中序遍历， 而后续遍历正是在中序遍历的基础上修改的。
                      root = root.right
  
              else:
                  # 左子树不存在，则添加root.val,进入右子树,右子节点可能指向当前root的父节点
                  res.append(root.val)
                  root = root.right
          return res
      
  Morris(后续遍历，在中序遍历基础上修改而来)
  对于root的左子树：中序遍历为：左中右，通过反转中右，可以获得左右中。
  
  class Solution:
      def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
          if not root:
              return []
  
          res = []
          def addPath(node):             
              count = 0
              # 将node到该子树最右侧的节点加入res
              while node:
                  res.append(node.val)
                  count += 1                
                  node = node.right
  
              # 反转i~j的数值：左中右=》左右中
              i = len(res) - count
              j = len(res) - 1
  
              while i < j:
                  res[i], res[j] = res[j], res[i]
                  i += 1
                  j -= 1
          
          p = root
          while p:
              if p.left:
                  most_right = p.left
                  while most_right.right and most_right.right != p:
                      most_right = most_right.right
                  # most_right 是左子树最右侧的点
  
                  if not most_right.right:
                      # 第一次
                      most_right.right = p
                      p = p.left
  
                  else:
                      # 第二次
                      most_right.right = None
                      addPath(p.left)
                      p = p.right
              else:
                  p = p.right
          # 加入root到最右节点的所有节点
          addPath(root)
          return res
  ```
  
  
  
  
  
  - 层序遍历(只要会了基础的写法，所有问题只是在层序遍历上的微操而已)
    - [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
  
    - #### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)
  
    - [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)
  
    - BFS，层序遍历，最短路径是递进的关系
      - 在BFS 上记录区分遍历的每一层 -> 层序遍历
      - 在层序遍历的基础上记录层数 -> 最短路径
      
    - 应用在最短路径（图的BFS）：[1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)
      - tree只有一个root；而图可以有多个起始节点，都添加进入queue即可。
      - tree是有方向的，无需代表是否访问过的标志位；但是图需要标志位
      
  
  - 垂序遍历
  
    - [987. 二叉树的垂序遍历](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/)
  
- 递归
  - 树天生适合递归，解决树的属性的问题。
  - [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)
  - 
  - [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
  
- 二叉树属性

  - [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)
  - [104. 二叉树的最大深度 ](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) 
  - [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
  - [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)
  - [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)
  - 

- 二叉树重建：
  - 重要的思想是：首先找到根节点，根据根节点在另外一个序列中找到对应的位置以区分左右子树。
  - 前+中，可以唯一确定树结构
  - 后+中，可以唯一确定树结构
  - 前+后，不能唯一确定树结构
  - [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
  - [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
  - [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)
  - [1008. 前序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)
  
- 二叉搜索树
  - [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)
  - 

- 前缀树
  - [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
  - [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)
  - [面试题 17.17. 多次搜索](https://leetcode-cn.com/problems/multi-search-lcci/)

------

