## Think deeply--动态规划

- 状态定义
- 状态转移
- 状态初始化



## 0-1背包问题

- 背包问题：
  - 每个物体只有两个状态：选or不选
  - 一个个地考虑物品，一点点地扩大容量，**找到满足和为target的子集**
  - **很多题目没有直接告诉target，而需要简单的转化、运算得到target**
- 状态定义：
  - dp[i,j] 在nums[0:i]中和为j的子集的个数
- 状态转移：
  - dp[i, j] =  dp[i - 1, j]，**若nums[i] > j** 
  - dp[i, j] =  dp[i - 1, j] + dp[i - 1, j - nums[i]]，**若nums[i] <= j**, 其中两项分别对应着:不采用nums[i], 采用nums[i]
  - **最终结果为dp[nums.size() - 1, neg]**
- 使用滚动数组优化空间复杂度，为线性空间复杂度。由状态转移方程决定，需要从后往前更新。
- 题目
  - [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)
  - [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

## 完全背包问题

- 

- 题目：
  - [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
    - 状态定义
      - dp[i]：和为i的最小数量
    - 状态转移
      - dp[i] = min( dp[i - coins[0]]  + 1, ..., dp[i - coins[n]] + 1)
  - [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)
    - 注意数字可以重复使用
    - 状态定义，dp[i,j] 从coins[0:i]中和为j有多少组数
    - 状态转移：`dp[i,j]=dp[i-1, j] + dp[i][j-coins[i]] 分别对应不使用coins[i] 和使用coins[i] 由于数量无限，所以第二项不能是dp[i-1][j-coins[j]]`



## 最长公共子串

- 求两个数组或者字符串的最长公共子序列问题，肯定是要用动态规划的。下面的题解并不难，你肯定能看懂。

  - 首先，区分两个概念：子序列可以是不连续的；子数组（子字符串）需要是连续的；
  - 另外，动态规划也是有套路的：
    - **单个数组或者字符串要用动态规划时，可以把动态规划 dp[i] 定义为 nums[0:i] 中想要求的结果**；
    - **当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 `dp[i][j]` ，其含义是在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果。**

- 状态定义：

  - 定义 `dp[i][j]` 表示 `text1[0:i-1]` 和 `text2[0:j-1]` 的最长公共子序列。即i,j 索引代表字符串的长度。i或j=0代表空字符串。

- 状态转移：

  - $$
    dp[i][j]=dp[i−1][j−1]+1, 当 text1[i - 1] == text2[j - 1];
    $$

  - $$
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]
    $$

- 状态初始化
