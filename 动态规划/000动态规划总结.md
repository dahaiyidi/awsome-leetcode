## Think deeply--动态规划

- 状态定义
- 状态转移
- 状态初始化



## 0-1背包问题

- 背包问题：
  - 每个物体只有两个状态：选or不选
  - 一个个地考虑物品，一点点地扩大容量
- 状态定义：
  - 

- 使用滚动数组优化空间复杂度。由状态转移方程决定，需要从后往前更新。
- 题目
  - [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)



「力扣」第 474 题：一和零（中等）；
「力扣」第 494 题：目标和（中等）；
「力扣」第 879 题：盈利计划（困难）；

https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg

## 完全背包问题

- 题目：
  - [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
  - [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

「力扣」第 322 题：零钱兑换（中等）；
「力扣」第 518 题：零钱兑换 II（中等）；
「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）。



## 最长公共子串

- 求两个数组或者字符串的最长公共子序列问题，肯定是要用动态规划的。下面的题解并不难，你肯定能看懂。

  - 首先，区分两个概念：子序列可以是不连续的；子数组（子字符串）需要是连续的；
  - 另外，动态规划也是有套路的：
    - **单个数组或者字符串要用动态规划时，可以把动态规划 dp[i] 定义为 nums[0:i] 中想要求的结果**；
    - **当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 `dp[i][j]` ，其含义是在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果。**

- 状态定义：

  - 定义 `dp[i][j]` 表示 `text1[0:i-1]` 和 `text2[0:j-1]` 的最长公共子序列。即i,j 索引代表字符串的长度。i或j=0代表空字符串。

- 状态转移：

  - $$
    dp[i][j]=dp[i−1][j−1]+1, 当 text1[i - 1] == text2[j - 1];
    $$

  - $$
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]
    $$

- 状态初始化
