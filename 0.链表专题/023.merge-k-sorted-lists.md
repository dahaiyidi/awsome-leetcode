## Problem

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

++

难度困难1659

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

------

### Note

- **分治：**

- 时间O：kn*logk，空间O：log(k), k 是list的个数

- 第一次：k/2组，每一组需要2n次合并；第二次，k/4组，每组需要4n次合并，...时间复杂度如下：

- $$
  \sum_{i=1}^{log_2k}k/2^i * 2^in=\sum_{i=1}^{log_2k}kn=kn*logk
  $$

**按顺序：**

- 故渐进时间复杂度为 O(k^2 n)*O*(*k*2*n*)。
- 空间复杂度：没有用到与 k*k* 和 n*n* 规模相关的辅助空间，故渐进空间复杂度为 O(1)*O*(1)。

**优先队列：**

时间复杂度：考虑优先队列中的元素不超过 kk 个，那么插入和删除的时间代价为 O(\log k)O(logk)，这里最多有 knkn 个点，对于每个点都被插入删除各一次，故总的时间代价即渐进时间复杂度为 O(kn \times \log k)O(kn×logk)。
空间复杂度：这里用了优先队列，优先队列中的元素不超过 kk 个，故渐进空间复杂度为 O(k)O(k)。



------

### Complexity

- 时间O：
- 空间O：

------

### Python

```python
分治


class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return 
        n = len(lists)
        return self.merge(lists, 0, n-1)
    def merge(self,lists, left, right):
        if left == right:
            # 直接返回该链表
            return lists[left]
        mid = left + (right - left) // 2
        return self.mergeTwoLists(self.merge(lists, left, mid), self.merge(lists, mid + 1, right))
        
    def mergeTwoLists(self,l1, l2):
        if not l1:
            return l2
        if not l2:
            return l1

        dummy = ListNode(0)
        pre = dummy
        while l1 and l2:
            if l1.val < l2.val:
                pre.next = l1
                l1 = l1.next
            else:
                pre.next = l2
                l2 = l2.next
            pre = pre.next
        if l1:
            pre.next = l1
        if l2:
            pre.next = l2
        return dummy.next
```



```python

```



### C++

```C++

```



From : https://github.com/dahaiyidi/awsome-leetcode
