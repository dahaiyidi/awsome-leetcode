## Problem

#### [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

++

难度中等460

给你一个整数数组 `nums`，请你将该数组升序排列。



------

### Note

- 快排（分治）—— 时间：nlogn, 空间：最坏情况下需 O(*n*) 的空间，最优情况下每次都平衡为O(logn)
- 堆排序——时间：nlogn, 空间：1
- 归并排序（分治）——时间：nlogn, 空间n
- 插入排序——时间：n^2, 空间1，在数组「几乎有序」的前提下，「插入排序」的时间复杂度可以达到 O(N)；在短数组上表现良好。
  - 由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素
- ![img](../imgs/clipboard-16423455063141.png)

------

### Complexity

- 时间O：
- 空间O：

------

### Python

```python
方法1：快排
class Solution:
    def partition(self, nums, l, r):
        pivot = random.randint(l, r)
        # 将随机选中的值移动到最后
        nums[pivot], nums[r] = nums[r], nums[pivot]
        # i 为下一个<nums[pivot] 的值存放的地方
        # 最终i的位置为nums[pivot]应该交换到的地方
        i = l 
        for j in range(l, r):
            if nums[j] < nums[r]:
                nums[j], nums[i] = nums[i], nums[j]
                i += 1
                
        nums[r], nums[i] = nums[i], nums[r]
        return i

    def quicksort(self, nums, l, r):
        if l >= r:
            return
        
        i = self.partition(nums, l, r)
        self.quicksort(nums, l, i - 1)
        self.quicksort(nums, i + 1, r)
        

    def sortArray(self, nums: List[int]) -> List[int]:
        self.quicksort(nums, 0, len(nums) - 1);
        return nums
方法2 堆排序

```

### C++

```C++

```



From : https://github.com/dahaiyidi/awsome-leetcode
