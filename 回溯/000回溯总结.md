## Problem

回溯：

https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/

https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/

------

### 子集和组合

思路：

- 子集、组合是**无关顺序的**

- 形式是统一的，只是在判断的细节上有区别

- **关键是用一个 start 参数来控制选择列表**

- 部分题目可以通过sort后，再进行回溯，便于剪枝：[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)        [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

- 元素可以重复不限次数使用：在for循环中，`func(candidates, i, target - candidates[i], res, path);`  i不需要+1

- 数字不能重复（res的元素不能重复）：

  - sort  （如果数组中含有重复的元素，必须要sort）
  - if(i > start && nums[i] == nums[i - 1]){continue;}

  ```
  [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)
  
  class Solution {
  public:
      void dfs(vector<int>& candidates, int start, int target, vector<vector<int>>& res, vector<int>& path){
          if(target == 0){
              res.emplace_back(path);
              return;
          }
  
          for(int i = start; i < candidates.size(); i++){
              // 同一层不能重复使用重复出现的数字，但是不同层是可以使用重复的数字，否则res会有重复的元素
              // 防止重复必备（如果数组中含有重复的元素）
              if(i > start && candidates[i] == candidates[i - 1]){
                  continue;
              }
              
              // 剪枝
              if(candidates[i] > target){
                  // 若candidates[i] > target， 则可以终止本层次，因为后面的元素会更大，更不符合要求
                  break;
              }
              path.emplace_back(candidates[i]);
              dfs(candidates, i + 1, target - candidates[i], res, path);
              path.pop_back();    
          }
      }
      
      vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
          vector<vector<int>> res;
          vector<int> path;
          sort(candidates.begin(), candidates.end()); // 从低到高排序,以剪枝 // 防止重复必备（如果数组中含有重复的元素，必须要sort）
  
          dfs(candidates, 0, target, res, path);
          return res;
  
      }
  };
  ```
  
- 其他题目：

- [77. 组合](https://leetcode-cn.com/problems/combinations/)
- [78. 子集](https://leetcode-cn.com/problems/subsets/)
- [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)



------

### 排列类题目

- 排列类的题目，**和元素的顺序相关的**

主要的流程（[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)）：

- 使用used标记是否被使用过
- sort避免返回的res含有重复的元素
- 注意跳过元素，if(used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])){
                  continue;
              }

```c++
class Solution {
public:
    void dfs(vector<int>& nums, int depth, vector<vector<int>>& res, vector<int>& path, vector<bool>& used){
        if(depth == nums.size()){
            res.emplace_back(path);
            return;
        }

        for(int i = 0; i < nums.size(); i++){
            // 第i已经使用过，则跳过
            // 如果nums[i] == nums[i - 1]， 且nums[i - 1]还没有被使用过(如果不排除，会出现重复的元素)。对于重复的数值，同一层只能使用一层，而如果nums[i - 1]被使用过，则说明是在不同层考虑进入该重复数值。
            if(used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])){
                continue;
            }
            used[i] = true;
            path.emplace_back(nums[i]);
            dfs(nums, depth + 1, res, path, used);
            used[i] = false;
            path.pop_back();            
        }
        
    }

    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        vector<bool> used(nums.size(), false);
        // 避免重复必备
        sort(nums.begin(), nums.end()); 
        dfs(nums, 0, res, path, used);
        return res;
    }
};
```



- 题目：
  - [46. 全排列](https://leetcode-cn.com/problems/permutations/)
  - [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)
  - [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)
  - [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)
  
  



------

### 搜索类题目

- 排列类的题目，和元素的顺序相关的

- 典型题目：[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

  - 时间O：`M*N*(3^L)`  M，N为board的大小，由于每次又3个分支（虽然写了4个，但是来时的路不会再访问），有L次3个分支，L为word的长度。然而，由于剪枝的存在，我们在遇到不匹配或已访问的字符时会提前退出，终止递归流程。因此，实际的时间复杂度会远远小于`M*N*(3^L)` 
  - 空间O：`M*N`
  
  ```c++
  class Solution {
  public:
      const int dx[4] = {-1, 1, 0, 0};
      const int dy[4] = {0, 0, -1, 1};
      bool dfs(vector<vector<char>>& board, string& word, vector<vector<bool>>& used, int i, int j, int idx){
          if(idx == word.size() - 1){
              return board[i][j] == word[idx];
          }
  
          // 若当前匹配的字符符合要求
          if(board[i][j] != word[idx]){
              return false;
          }
  
          bool res = false;
          // 标记当前节点已经访问
          used[i][j] = true;
          // 上下左右尝试
          for(int k = 0; k < 4; k++){
              int new_x = i + dx[k];
              int new_y = j + dy[k];
              if(new_x >= 0 && new_x <= board.size() - 1 && new_y >= 0 && new_y <= board[0].size() - 1 && !used[new_x][new_y]){
                  if(dfs(board, word, used, new_x, new_y, idx + 1)){
                      res = true;
                      break;
                  }
              }
          }
          // 标记当前节点未访问
          used[i][j] = false;
          
          return res;
      }
      bool exist(vector<vector<char>>& board, string word) {
          vector<vector<bool>> used(board.size(), vector<bool>(board[0].size()));
          for(int i = 0; i < board.size(); i++){
              for(int j = 0; j < board[0].size(); j++){
                  if(dfs(board, word, used, i, j, 0)){
                      return true;
                  }
              }
          }
          return false;
      }
  };
  ```
  
  - [面试题 08.12. 八皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)
  - 

[分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)、[二进制手表](https://leetcode-cn.com/problems/binary-watch/)

[「力扣」第 130 题：被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)、[「力扣」第 200 题：岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)。

