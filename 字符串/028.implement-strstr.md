## Problem

#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 `-1` 。

 

**说明：**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与 C 语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java 的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

 

**示例 1：**

```
输入：haystack = "hello", needle = "ll"
输出：2
```

------

### Note

- 除了一点点的匹配之外，还有KMP算法，KMP算法的讲解：https://www.zhihu.com/question/21923021/answer/281346746
- 最重要的是要求出pattern的next数组。为了方便，next[i]的数组代表着pattern[0, i - 1]的前缀子集和后缀子集的交集的最长字符串长度。在此处，字符串本身不是自己的子串。

------

### Complexity

n: 待匹配字符串的长度

m: pattern字符串的长度。

- 时间O：O(n+m)

- 空间O：O(m)

  

------

### Python

```python

```

### C++

```C++
class Solution {
public:
    int strStr(string t, string p) {
        if(p == ""){
            return 0;
        }
        vector<int> next(p.size(), 0);
        next[0] = -1;
        int i = 0, j = -1;

        // 求next数组
        while(i < p.size() - 1){
            if(j == -1 || p[i] == p[j]){
                i++;
                j++;
                next[i] = j;
            }
            else{
                j = next[j];
            }
        }

        i = 0, j = 0;
        while(i < t.size() && j < (int) p.size()){
            if(j == -1 || t[i] == p[j]){
                i++;
                j++;
            }
            else{
                j = next[j];
            }
        }
        if(j == p.size()){
            return i - j;
        }
        else{
            return -1;
        }

    }
};
```



From : https://github.com/dahaiyidi/awsome-leetcode
